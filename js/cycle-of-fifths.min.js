(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var noteName = require('tonal/note/name')
var chord = require('tonal/chord/chord')
var fifths = require('tonal/cycles/fifths')

addChord('CM')
addChord('Cm')
addChord('C+')
addChord('Cdim')
addChord('Cmaj7')
addChord('Cm7')
addChord('C7')
addChord('Cm7b5')

function addChord (name) {
  var c = chord(name)
  var notes = c.map(noteName).join(' ')
  var label = 'Chord: ' + name + ' (' + notes + ')'
  var indexes = c.map(fifths)
  addCycle(label, indexes)
}

function addCycle (label, indexes) {
  var canvas = document.createElement('canvas')
  var size = 120
  var diameter = size - 40

  var center = { x: size, y: size }
  canvas.width = center.x * 2
  canvas.height = center.y * 2
  var ctx = canvas.getContext('2d')
  ctx.lineWidth = 0.5

  // circle
  ctx.beginPath()
  ctx.strokeStyle = 'black'
  ctx.arc(center.x, center.y, diameter, 0, Math.PI * 2)
  ctx.closePath()
  ctx.stroke()

  var notes = 'Eb/D# Bb/A# F C G D A E B Gb/F# Db/C# Ab/G#'.split(' ')
  // mark the notes
  ctx.font = '10px sans-serif'
  for (var n = 0; n < 12; n++) {
    var angle = n * (Math.PI * 2 / 12)
    ctx.moveTo(circleX(angle, -5), circleY(angle, -5))
    ctx.lineTo(circleX(angle, 5), circleY(angle, 5))
    ctx.fillText(notes[n], circleX(angle, 12) - 4, circleY(angle, 12) + 4)
    ctx.stroke()
  }

  function circleX (angle, size) { return center.x + Math.cos(angle) * (diameter + size) }
  function circleY (angle, size) { return center.y + Math.sin(angle) * (diameter + size) }

  indexes = indexes.sort()
  console.log(indexes)
  for (var i = 0, len = indexes.length; i < len; i++) {
    drawLine(indexes[i], indexes[(i + 1) % len])
  }

  function drawLine (a, b) {
    ctx.strokeStyle = 'red'
    angle = (a + 3) % 12 * (Math.PI * 2 / 12)
    ctx.moveTo(circleX(angle, 0), circleY(angle, 0))
    angle = (b + 3) % 12 * (Math.PI * 2 / 12)
    ctx.lineTo(circleX(angle, 0), circleY(angle, 0))
    ctx.stroke()
  }

  var measure = ctx.measureText(label)
  ctx.fillText(label, size - (measure.width / 2), size * 2 - 12)

  document.getElementById('cycles').appendChild(canvas)
}

},{"tonal/chord/chord":2,"tonal/cycles/fifths":5,"tonal/note/name":29}],2:[function(require,module,exports){
var data = require('./chords-all.json')
var dictionary = require('../set/dictionary')
var parse = require('./parse')

/**
 * A chord set generator
 *
 * Given a chord name returns the intervals or notes
 *
 * @param {String} name - a chord name (with or without tonic)
 * @return {Array} a set (of notes or intervals depending on the name)
 *
 * @see set/dictionary
 *
 * @example
 * chord('M') // => ['P1', 'M3', 'P5']
 * chord('C7') // => ['C4', 'E4', 'G4', 'B4']
 */
module.exports = dictionary(data, parse)

},{"../set/dictionary":36,"./chords-all.json":3,"./parse":4}],3:[function(require,module,exports){
module.exports={
  "2": "P1 M3 P5 M2",
  "4": "P1 P4 m7 m10",
  "5": "P1 P5",
  "6": "P1 M3 P5 M6",
  "7": "P1 M3 P5 m7",
  "9": "P1 M3 P5 m7 M9",
  "10": "P1 P5 M3",
  "11": "P1 P5 m7 M9 P11",
  "13": "P1 M3 P5 m7 M9 M13",
  "67": "P1 M3 P5 m7 M13",
  "69": "P1 M3 P5 M6 M2",
  "M": "P1 M3 P5",
  "M6": "P1 M3 P5 M6",
  "M69": "P1 M3 P5 M6 M2",
  "M6#11": "P1 M3 P5 M6 A4",
  "M69#11": "P1 M3 P5 M6 M2 A4",
  "Madd9": "P1 M3 P5 M2",
  "Msus2": "P1 M2 P5",
  "sus24": "P1 M2 P4 P5",
  "M7": "P1 M3 P5 M7",
  "M9": "P1 M3 P5 M7 M9",
  "M7#11": "P1 M3 P5 M7 A11",
  "M9#11": "P1 M3 P5 M7 M9 A11",
  "M13": "P1 M3 P5 M7 M9 M13",
  "M7add13": "P1 M3 P5 M6 M7 M9",
  "M13#11": "P1 M3 P5 M7 M9 A11 M13",
  "69#11": "P1 M3 P5 M6 M2 A4",
  "Mb5": "P1 M3 d5",
  "M7b5": "P1 M3 d5 M7",
  "M9b5": "P1 M3 d5 M7 M9",
  "M7#9#11": "P1 M3 P5 M7 A9 A11",
  "Msus4": "P1 P4 P5",
  "M7b6": "P1 M3 m6 M7",
  "9no5": "P1 M3 m7 M9",
  "M#5": "P1 M3 A5",
  "M7#5": "P1 M3 A5 M7",
  "M9#5": "P1 M3 A5 M7 M9",
  "M#5add9": "P1 M3 A5 M2",
  "M7sus4": "P1 P4 P5 M7",
  "M9sus4": "P1 P4 P5 M7 M9",
  "M7#5sus4": "P1 P4 A5 M7",
  "M9#5sus4": "P1 P4 A5 M7 M9",
  "+add#9": "P1 M3 A5 A2",
  "M7b9": "P1 M3 P5 M7 m9",
  "Mb6": "P1 M3 m6",
  "m": "P1 m3 P5",
  "m7": "P1 m3 P5 m7",
  "m6": "P1 m3 P4 P5 M6",
  "m69": "P1 m3 P5 M6 M2",
  "madd9": "P1 m3 P5 M2",
  "madd4": "P1 m3 P4 P5",
  "mM7": "P1 m3 P5 M7",
  "mM9": "P1 m3 P5 M7 M9",
  "mM7b6": "P1 m3 P5 m6 M7",
  "mM9b6": "P1 m3 P5 m6 M7 M9",
  "m9": "P1 m3 P5 m7 M9",
  "m11": "P1 m3 P5 m7 M9 P11",
  "m7add11": "P1 m3 P5 m7 P11",
  "m13": "P1 m3 P5 m7 M9 P11 M13",
  "m7b5": "P1 m3 d5 m7",
  "m9b5": "P1 m3 m7 d12 M9",
  "m11b5": "P1 m3 m7 d12 M9 P11",
  "m#5": "P1 m3 A5",
  "mb6b9": "P1 m3 m6 m2",
  "mb6M7": "P1 m3 m6 M7",
  "m7#5": "P1 m3 m6 m7",
  "m9#5": "P1 m3 m6 m7 M9",
  "m11#5": "P1 m3 m6 m7 M9 P11",
  "addb9": "P1 M3 P5 m2",
  "7no5": "P1 M3 m7",
  "7b9": "P1 M3 P5 m7 m9",
  "7b9#9": "P1 M3 P5 m7 m9 A9",
  "7#5": "P1 M3 A5 m7",
  "7#9": "P1 M3 P5 m7 A9",
  "7#11": "P1 M3 P5 m7 A11",
  "7#9#11": "P1 M3 P5 m7 A9 A11",
  "7#9b13": "P1 M3 P5 m7 A9 m13",
  "7#9#11b13": "P1 M3 P5 m7 A9 A11 m13",
  "7b5": "P1 M3 d5 m7",
  "9#11": "P1 M3 P5 m7 M9 A11",
  "9b5": "P1 M3 d5 m7 M9",
  "9#5": "P1 M3 A5 m7 M9",
  "9#5#11": "P1 M3 A5 m7 M9 A11",
  "11b9": "P1 P5 m7 m9 P11",
  "7add6": "P1 M3 P5 m7 M13",
  "13no5": "P1 M3 m7 M9 M13",
  "7b13": "P1 M3 m7 m13",
  "7b6": "P1 M3 P5 m6 m7",
  "9b13": "P1 M3 m7 M9 m13",
  "7#11b13": "P1 M3 P5 m7 A11 m13",
  "9#11b13": "P1 M3 P5 m7 M9 A11 m13",
  "13b9": "P1 M3 P5 m7 m9 M13",
  "13b5": "P1 M3 d5 M6 m7 M9",
  "13#9": "P1 M3 P5 m7 A9 M13",
  "13#11": "P1 M3 P5 m7 M9 A11 M13",
  "13#9#11": "P1 M3 P5 m7 A9 A11 M13",
  "7sus4": "P1 P4 P5 m7",
  "9sus4": "P1 P4 P5 m7 M9",
  "7#5sus4": "P1 P4 A5 m7",
  "7sus4b9": "P1 P4 P5 m7 m9",
  "7sus4b9b13": "P1 P4 P5 m7 m9 m13",
  "13sus4": "P1 P4 P5 m7 M9 M13",
  "7b9#11": "P1 M3 P5 m7 m9 A11",
  "13b9#11": "P1 M3 P5 m7 m9 A11 M13",
  "7b9b13": "P1 M3 P5 m7 m9 m13",
  "7b9b13#11": "P1 M3 P5 m7 m9 A11 m13",
  "7#5b9": "P1 M3 A5 m7 m9",
  "7#5b9#11": "P1 M3 A5 m7 m9 A11",
  "7#5#9": "P1 M3 A5 m7 A9",
  "o": "P1 m3 d5",
  "o7": "P1 m3 d5 M6",
  "oM7": "P1 m3 d5 M7",
  "o7M7": "P1 m3 d5 M6 M7",
  "Blues": "P1 m3 P4 d5 P5 m7",
  "m10": "P1 P5 m3",
  "Major": "P1 M3 P5",
  "minor": "P1 m3 P5",
  "minor7": "P1 m3 P5 m7",
  "Dominant": "P1 M3 P5 m7",
  "augmented": "P1 M3 A5",
  "diminished": "P1 m3 d5 M6",
  "half-diminished": "P1 m3 d5 m7",
  "quartal": "P1 P4 m7 m10",
  "": "P1 M3 P5",
  "M6b5": "P1 M3 P5 M6 A4",
  "6#11": "P1 M3 P5 M6 A4",
  "6b5": "P1 M3 P5 M6 A4",
  "add9": "P1 M3 P5 M2",
  "add9no3": "P1 M2 P5",
  "sus": "P1 P4 P5",
  "sus2": "P1 M2 P5",
  "add2": "P1 M3 P5 M2",
  "sus4add9": "P1 M2 P4 P5",
  "maj7": "P1 M3 P5 M7",
  "Maj7": "P1 M3 P5 M7",
  "maj9": "P1 M3 P5 M7 M9",
  "Maj9": "P1 M3 P5 M7 M9",
  "maj7#11": "P1 M3 P5 M7 A11",
  "Maj7#11": "P1 M3 P5 M7 A11",
  "maj9#11": "P1 M3 P5 M7 M9 A11",
  "Maj9#11": "P1 M3 P5 M7 M9 A11",
  "maj13": "P1 M3 P5 M7 M9 M13",
  "Maj13": "P1 M3 P5 M7 M9 M13",
  "maj13#11": "P1 M3 P5 M7 M9 A11 M13",
  "Maj13#11": "P1 M3 P5 M7 M9 A11 M13",
  "sus4": "P1 P4 P5",
  "susb9": "P1 P4 P5 m7 m9",
  "7susb9": "P1 P4 P5 m7 m9",
  "7b9sus": "P1 P4 P5 m7 m9",
  "7b9sus4": "P1 P4 P5 m7 m9",
  "phryg": "P1 P4 P5 m7 m9",
  "maj#5": "P1 M3 A5",
  "Maj#5": "P1 M3 A5",
  "maj7#5": "P1 M3 A5 M7",
  "Maj7#5": "P1 M3 A5 M7",
  "maj9#5": "P1 M3 A5 M7",
  "Maj9#5": "P1 M3 A5 M7 M9",
  "+": "P1 M3 A5",
  "aug": "P1 M3 A5",
  "M7+": "P1 M3 A5 M7",
  "+add9": "P1 M3 A5 M2",
  "mMaj7": "P1 m3 P5 M7",
  "mMaj9": "P1 m3 P5 M7 M9",
  "mMaj7b6": "P1 m3 P5 m6 M7",
  "mMaj9b6": "P1 m3 P5 m6 M7 M9",
  "m7add4": "P1 m3 P5 m7 P11",
  "h7": "P1 m3 d5 m7",
  "mb5": "P1 m3 d5",
  "m6b5": "P1 m3 d5 M6",
  "h9": "P1 m3 m7 d12 M9",
  "h11": "P1 m3 m7 d12 M9 P11",
  "m+": "P1 m3 A5",
  "mb6": "P1 m3 A5",
  "+7": "P1 M3 A5 m7",
  "7+": "P1 M3 A5 m7",
  "7aug": "P1 M3 A5 m7",
  "aug7": "P1 M3 A5 m7",
  "7b5#9": "P1 M3 P5 m7 A9 A11",
  "9+": "P1 M3 A5 m7 M9",
  "7add13": "P1 M3 P5 m7 M13",
  "9b5b13": "P1 M3 P5 m7 M9 A11 m13",
  "7sus": "P1 P4 P5 m7",
  "9sus": "P1 P4 P5 m7 M9",
  "7b9b13sus4": "P1 P4 P5 m7 m9 m13",
  "13sus": "P1 P4 P5 m7 M9 M13",
  "7b9#11b13": "P1 M3 P5 m7 m9 A11 m13",
  "7b5b9": "P1 M3 P5 m7 m9 A11",
  "7b5b13": "P1 M3 P5 m7 A11 m13",
  "7b5b9b13": "P1 M3 P5 m7 m9 A11 m13",
  "7alt": "P1 M3 A5 m7 A9",
  "dim": "P1 m3 d5",
  "dim7": "P1 m3 d5 M6",
  "-": "P1 m3 P5 m7",
  "-7": "P1 m3 P5 m7",
  "-9": "P1 m3 P5 m7 M9",
  "-11": "P1 m3 P5 m7 M9 P11",
  "-13": "P1 m3 P5 m7 M9 P11 M13",
  "-7b5": "P1 m3 d5 m7",
  "-9b5": "P1 m3 m7 d12 M9",
  "-11b5": "P1 m3 m7 d12 M9 P11",
  "-6": "P1 m3 P4 P5 M6",
  "-69": "P1 m3 P5 M6 M2",
  "-M7": "P1 m3 P5 M7",
  "-M9": "P1 m3 P5 M7 M9",
  "7+4": "P1 M3 P5 m7 A11",
  "7#4": "P1 M3 P5 m7 A11",
  "9+4": "P1 M3 P5 m7 M9 A11",
  "9#4": "P1 M3 P5 m7 M9 A11",
  "13+4": "P1 M3 P5 m7 M9 A11 M13",
  "13#4": "P1 M3 P5 m7 M9 A11 M13",
  "M7+4": "P1 M3 P5 M7 A11",
  "M7#4": "P1 M3 P5 M7 A11",
  "M9+4": "P1 M3 P5 M7 M9 A11",
  "M9#4": "P1 M3 P5 M7 M9 A11",
  "M13+4": "P1 M3 P5 M7 M9 A11 M13",
  "M13#4": "P1 M3 P5 M7 M9 A11 M13",
  "7_": "P1 M3 P5 m7",
  "9_": "P1 M3 P5 m7 M9",
  "13_": "P1 M3 P5 m7 M9 M13",
  "7#11_": "P1 M3 P5 m7 A11",
  "9#11_": "P1 M3 P5 m7 M9 A11",
  "13#11_": "P1 M3 P5 m7 M9 A11 M13",
  "7#4_": "P1 M3 P5 m7 A11",
  "9#4_": "P1 M3 P5 m7 M9 A11",
  "13#4_": "P1 M3 P5 m7 M9 A11 M13",
  "13#9_": "P1 M3 P5 m7 A9 M13",
  "7#9_": "P1 M3 P5 m7 A9",
  "7#5#9_": "P1 M3 A5 m7 A9",
  "7#9b13_": "P1 M3 A5 m7 A9"
}
},{}],4:[function(require,module,exports){
var noteParse = require('../note/parse')
/**
 * Parse a chord name and returns the tonic (if any) and the chord type
 */
function parse (chord) {
  var tonic = null
  var type = chord.trim()
  try {
    tonic = noteParse(type, true).note
    type = type.substring(tonic.length).trim()
  } catch (e) {}
  return { tonic: tonic, type: type }
}

module.exports = parse

},{"../note/parse":31}],5:[function(require,module,exports){
var name = require('../note/name')

var ASC = 'C G D A E B F# C# G# D# A# E#'.split(' ')
var DESC = 'C F Bb Eb Ab Db Gb Cb Fb Bbb Ebb Abb'.split(' ')
/**
 * Get the relation between a note and the number of steps in the
 * cycle of fifths (with root in C)
 *
 * @param {Integer|String} step - if it's an integer, returns the note step after
 * moving `step` steps in the cycle. If it's a step string, returns the number
 * of steps starting from 'C' to the given step
 * @return {String|Integer} - the note name or the number of steps (depending of the param)
 *
 * @example
 * var cycle = require('tonal/cycle-of-fifths')
 * cycle(0) // => 'C'
 * cycle(1) // => 'G'
 * cycle(-1) // => 'F'
 * cycle('C') // => 0
 * cycle('G') // => 1
 * cycle('F') // => -1
 * cycle('C2') // => undefined
 */
function fifths (step) {
  if (/^\d+$/.test(step)) {
    return ASC[+step % 12]
  } else if (/^-\d+$/.test(step)) {
    return DESC[Math.abs(+step) % 12]
  } else if (typeof step === 'string') {
    step = name(step)
    var index = ASC.indexOf(step)
    if (index > 0) {
      return index
    } else {
      index = DESC.indexOf(step)
      return index < 0 ? undefined : -1 * index
    }
  }
}

module.exports = fifths

},{"../note/name":29}],6:[function(require,module,exports){
var parse = require('./parse')

/**
 * Get the interval direction (1 ascending, -1 descending)
 *
 * @param {String} interval - the interval
 * @return {Integer} the direction (1: ascending interval, -1: descending interval)
 *
 * @module interval
 * @example
 * direction('P5') // => 1
 * direction('P-4') // => -1
 */
function direction (interval) {
  return parse(interval).d
}
module.exports = direction

},{"./parse":16}],7:[function(require,module,exports){
var pc = require('../note/pitch-class')

/**
 * Get the distance in semitones between two notes
 *
 * @param {String} root - the root note
 * @param {String} destination - the destination note
 *
 * @module interval
 *
 * @example
 * distanceChromatic('C', 'G') // => 7
 * distanceChromatic('G', 'C') // => -7
 */
function distanceChromatic (root, dest) {
  return pc(dest) - pc(root)
}
module.exports = distanceChromatic

},{"../note/pitch-class":32}],8:[function(require,module,exports){
var step = require('../note/step')

var STEPS = {'C': 0, 'D': 1, 'E': 2, 'F': 3, 'G': 4, 'A': 5, 'B': 6}

/**
 * Get the generic interval distance between two notes
 *
 * @module interval
 *
 * @example
 * distanceGeneric('C', 'G') // => 4
 * distanceGeneric('G', 'C') // => -4
 */
function distanceGeneric (root, dest) {
  return STEPS[step(dest)] - STEPS[step(root)]
}
module.exports = distanceGeneric

},{"../note/step":33}],9:[function(require,module,exports){
var distanceGeneric = require('./distance-generic')
var distanceChromatic = require('./distance-chromatic')
var genericToDiatonic = require('./generic-to-diatonic')

/**
 * Get the interval between two notes
 *
 * @param {String} root - root or tonic note
 * @param {String} destination - the destination note
 * @return {String} an interval
 */
function distanceInterval (root, dest) {
  return genericToDiatonic(distanceGeneric(root, dest), distanceChromatic(root, dest))
}

module.exports = distanceInterval

},{"./distance-chromatic":7,"./distance-generic":8,"./generic-to-diatonic":10}],10:[function(require,module,exports){
var type = require('./generic-type')

var DIMISHED = { 1: -1, 2: 0, 3: 2, 4: 4, 5: 6, 6: 7, 7: 9, 8: 11 }

/**
 * Given a generic interval and a number of semitones, return the interval
 * (if exists)
 */
function genericToDiationic (generic, semitones) {
  var qualities = type(generic) === 'perfect' ? ['d', 'P', 'A'] : ['d', 'm', 'M', 'A']
  var dir = semitones < 0 ? '-' : ''
  var num = generic + 1
  var quality = qualities[semitones - DIMISHED[num]]
  return quality ? quality + dir + num : null
}
module.exports = genericToDiationic

},{"./generic-type":11}],11:[function(require,module,exports){
/**
 * Return the type ('perfect' or 'major') of the [generic interval](https://en.wikipedia.org/wiki/Generic_interval)
 *
 * A generic interval its the number of a diatonic interval
 *
 * @param {Integer} number - the generic interval (positive integer)
 * @return {String} the type ('perfect' or 'major')
 *
 * @example
 * genericType(0) // 'perfect'  <- unison
 * genericType(3) // 'perfect'  <- fourth
 * genericType(4) // 'perfect'  <- fifth
 * genericType(7) // 'perfect'  <- octave
 * genericType(8) // 'major'    <- nineth
 */
function genericType (generic) {
  var n = Math.abs(generic) % 7
  if (n === 0 || n === 3 || n === 4) return 'perfect'
  else return 'major'
}

module.exports = genericType

},{}],12:[function(require,module,exports){
var number = require('./number')
var numberToGeneric = require('./number-to-generic')
/**
 * Convert a [diatonic interval](https://en.wikipedia.org/wiki/Interval_(music))
 * into a [generic interval](https://en.wikipedia.org/wiki/Generic_interval)
 *
 * @param {String} interval - the diatonic interval
 * @return {Integer} the generic interval
 *
 * @see genericToDiatonic
 * @module interval
 *
 * @example
 * generic('M9') // => 1
 */
function generic (interval) {
  return numberToGeneric(number(interval))
}

module.exports = generic

},{"./number":15,"./number-to-generic":14}],13:[function(require,module,exports){
var INTERVAL = /^[AdmMP]-?\d+$/

function isInterval (interval) {
  return INTERVAL.test(interval)
}

module.exports = isInterval

},{}],14:[function(require,module,exports){

/**
 * Give a interval number, returns a [generic interval](https://en.wikipedia.org/wiki/Generic_interval)
 *
 * @param {Integer} number - the interval number
 * @return {Integer} the generic interval (an integer bewteen 0 and 6)
 */
function numberToGeneric (num) {
  if (num === 0) throw Error('0 is not a valid interval number')
  var dir = num > 0 ? 1 : -1
  return dir * (Math.abs(num) - 1) % 7
}
module.exports = numberToGeneric

},{}],15:[function(require,module,exports){
var parse = require('./parse')

/**
 * Return the number (diatonic number or generic interval) of an interval
 */
function number (interval) {
  return parse(interval).n
}
module.exports = number

},{"./parse":16}],16:[function(require,module,exports){
var REGEX = /^([AdmMP])(-?)(\d+)$/

/**
 * Get the interval components
 *
 * This method retuns an object with the following properties:
 * - q: the quality (one of `dmPMA` for dimished, minor, perfect, major and
 * augmented respectively)
 * - d: direction, 1 for ascending intervals, -1 for descending ones
 * - n: diatonic number (a positive integer bigger that 0)
 *
 * @param {String} name - the name of the interval to be parsed
 * @return {Array} an array in the form [quality, direction, number]
 *
 * @example
 * var parse = require('tonal/interval/parse')
 * parse('P-5') // => {q: 'P', d: -1, n: 5}
 * parse('M9') // => {q: 'M', d: 1, n: 9}
 */
function parse (interval) {
  var m = REGEX.exec(interval)
  if (!m) throw Error('Not an interval: ' + interval)
  return { q: m[1], d: m[2] === '' ? 1 : -1, n: +m[3] }
}

module.exports = parse

},{}],17:[function(require,module,exports){
var simple = require('./simple')
var direction = require('./direction')

// size in semitones to cannonical (perfect or major) generic intervals
var SIZES = { 1: 0, 2: 2, 3: 4, 5: 7, 6: 9, 7: 11, 8: 12 }
var DIMISHED = { 1: -1, 2: 0, 3: 2, 4: 4, 5: 6, 6: 7, 7: 9, 8: 11 }
var NAME_TO_DISTANCE = { 'd1': -1, 'P1': 0, 'A1': 1, 'd2': 0, 'm2': 1, 'M2': 2,
  'A2': 3, 'd3': 2, 'm3': 3, 'M3': 4, 'A3': 5, 'd4': 4, 'P4': 5, 'A4': 6,
  'd5': 6, 'P5': 7, 'A5': 8, 'd6': 7, 'm6': 8, 'M6': 9, 'A6': 10, 'd7': 9,
  'm7': 10, 'M7': 11, 'A7': 12, 'd8': 11, 'P8': 12, 'A8': 13 }

/**
 * Get the semitones distance of an intervals
 *
 * @param {String} interval - the interval
 * @return {Integer} the number of semitones
 *
 * @module interval
 * @example
 * semitones('P5') // => 7
 */
function semitones (interval) {
  return direction(interval) * NAME_TO_DISTANCE[simple(interval, true)]
}
module.exports = semitones

},{"./direction":6,"./simple":18}],18:[function(require,module,exports){
var parse = require('./parse')
var numberToGeneric = require('./number-to-generic')

/**
 * Simplify an interval
 *
 * @param {String} interval - the interval to be simplified
 * @param {boolean} ascending - (optional) if true, the simplified interval will
 * be always ascending
 *
 * @module interval
 *
 * @example
 * simple('M9') // => 'M2'
 * simple('M-9') // => 'M-2'
 * simple('M-9', true) // => 'M2'
 */
function simple (interval, ascending) {
  var i = parse(interval)
  var num = i.n === 8 ? 8 : numberToGeneric(i.n) + 1
  var dir = (ascending || i.d === 1) ? '' : '-'
  return i.q + dir + num
}

module.exports = simple

},{"./number-to-generic":14,"./parse":16}],19:[function(require,module,exports){

var midi = require('../note/midi')
var fromMidi = require('../note/from-midi')

function transposeChromatic (semitones, note) {
  return fromMidi(midi(note) + semitones)
}
module.exports = transposeChromatic

},{"../note/from-midi":26,"../note/midi":28}],20:[function(require,module,exports){
var step = require('../note/step')
var CLASSES = 'CDEFGABCDEFGAB'

/**
 * Transpose note a generic interval
 *
 * A generic interval is defined is the number part of a diationc interval
 * (2: ascendent second, 3: ascendent thirth, -4: descending fourth, ...)
 * The generic interval do not take account of diatonic spelling
 *
 * @param {Integer} generic - the generic interval
 * @param {String} note - the note (everything but the step is ignored)
 * @return {String} the tranposed step (in uppercase)
 *
 * @example
 * transpose(0, 'C') // => 'C'
 * transpose(1, 'C') // => 'D'
 * transpose(-1, 'C') // => 'B'
 */
function transposeGeneric (number, note) {
  var index = CLASSES.indexOf(step(note))
  var dest = index + (number % 7)
  if (dest < 0) dest += 7
  return CLASSES[dest]
}
module.exports = transposeGeneric

},{"../note/step":33}],21:[function(require,module,exports){
var transposeGeneric = require('./transpose-generic')
var transposeChromatic = require('./transpose-chromatic')
var generic = require('./generic')
var semitones = require('./semitones')
var enharmonic = require('../note/enharmonic')

function transposeDiatonic (interval, note) {
  var steps = transposeGeneric(generic(interval), note)
  var chromatic = transposeChromatic(semitones(interval), note)
  return enharmonic(chromatic, steps)
}
module.exports = transposeDiatonic

},{"../note/enharmonic":25,"./generic":12,"./semitones":17,"./transpose-chromatic":19,"./transpose-generic":20}],22:[function(require,module,exports){
/**
 * Given a number of accidentals returns the string representation
 *
 * @param {Integer} number - the number of accidentals (posivite for shaprs,
 * negative for flats, zero for an empty string)
 * @return {String} an accidentals string
 *
 * @example
 * var accidentals = require('tonal/misc/accidentals')
 * accidenals(2) // => '##'
 * accidenals(-2) // => 'bb'
 * accidenals(0) // => ''
 */
function accidentals (value) {
  value = +value
  if (value > 0) return Array(value + 1).join('#')
  else if (value < 0) return Array(Math.abs(value) + 1).join('b')
  else return ''
}

module.exports = accidentals

},{}],23:[function(require,module,exports){
var accidentals = require('./accidentals')

/**
 * @example
 * alteration('C#6') // 1
 * alteration('Db') // -1
 * alteration('E') // 0
 * alteration('#') // => 1
 * alteration('##') // => 2
 * alteration('b') // => -1
 * alteration('bb') // => -2
 * alteration('') // 0
 */
function alteration (value) {
  if (/^#+$/.test(value)) return value.length
  else if (/^b*$/.test(value)) return -1 * value.length
  else return alteration(accidentals(value))
}
module.exports = alteration

},{"./accidentals":22}],24:[function(require,module,exports){
var alter = require('../misc/alteration')
var parse = require('./parse')

/**
 * Return the alteration number of the note
 *
 * @param {String} note - the note
 * @return {Integer} the alteration number
 *
 * @see misc/alteration
 * @module note
 *
 * @example
 * alteration('C#6') // 1
 * alteration('Db') // -1
 * alteration('E') // 0
 * alteration('bb') // => -1 (first char is the step)
 */
function alteration (note) {
  return alter(parse(note).acc)
}
module.exports = alteration

},{"../misc/alteration":23,"./parse":31}],25:[function(require,module,exports){
var pc = require('./pitch-class')
var octave = require('./octave')
var accidentals = require('../misc/accidentals')

/**
 * Get the enharmonic of a note with a given step
 *
 * @example
 * enharmonic('C#4', 'D') // => 'Db4'
 * enharmonic('B#', 'C') // => 'C'
 */
function enharmonic (note, step) {
  var oct = octave(note)
  var dist = pc(note) - pc(step)
  if (dist > 6) {
    dist = dist - 12
    oct++
  } else if (dist < -6) {
    dist = dist + 12
    oct--
  }
  return step + accidentals(dist) + oct
}

module.exports = enharmonic

},{"../misc/accidentals":22,"./octave":30,"./pitch-class":32}],26:[function(require,module,exports){
'use strict'

var CHROMATIC = [ 'C', 'Db', 'D', 'Eb', 'E', 'F', 'F#', 'G', 'Ab', 'A', 'Bb', 'B' ]

/**
 * Get the note of the given midi number
 *
 * This method doesn't take into account diatonic spelling. Always the same
 * pitch class is given to the same midi number. @see enahrmonic
 *
 * @param {Integer} midi - the midi number
 * @return {String} the note or null if there's no pitchClass available to this note name
 *
 */
function fromMidi (midi) {
  var name = CHROMATIC[midi % 12]
  var oct = Math.floor(midi / 12) - 1
  return name + oct
}

module.exports = fromMidi

},{}],27:[function(require,module,exports){
var NOTE = /^([a-gA-G])(#{0,2}|b{0,2})(-?[0-9]{0,1})$/

/**
 * Determine if the given string is a valid note
 *
 * @param {String} string - the string to be tested
 * @return {Boolean} true if is a valid note
 */
function isNote (string) {
  return NOTE.test(string)
}

module.exports = isNote

},{}],28:[function(require,module,exports){
var pitchClass = require('./pitch-class')
var octave = require('./octave')

/**
 * Get the midi number of the given note
 *
 * @param {String} note - the note
 * @return {Integer} - the midi number
 *
 * @example
 * var midi = require('tonal/note/midi')
 * midi('A4') // => 69
 */
function midi (note) {
  return pitchClass(note) + 12 * (octave(note) + 1)
}

module.exports = midi

},{"./octave":30,"./pitch-class":32}],29:[function(require,module,exports){

var parse = require('./parse')

/**
 * Get the name (step and accidentals) of the note
 *
 * The step is __always__ in uppercase
 *
 * @param {String} note - the note
 * @return {String} the note name
 */
function name (note) {
  var n = parse(note)
  return n.step + n.acc
}
module.exports = name

},{"./parse":31}],30:[function(require,module,exports){

var parse = require('./parse')

function octave (note) {
  return parse(note).oct
}
module.exports = octave

},{"./parse":31}],31:[function(require,module,exports){

var STEP = '([a-gA-G])'
var ACC = '(#{1,4}|b{1,4}|x{1,2}|)'
var OCT = '(-?[0-9]{0,1})'
var NOTE = new RegExp('^' + STEP + ACC + OCT + '$')
var NAME_PREFIX = new RegExp('^' + STEP + ACC + '()')

/**
 * Get the components of a note (step, accidentals and octave)
 *
 * It returns an object with the following properties:
 * - step: the step letter __always__ in uppercase
 * - acc: a string with the accidentals or '' if no accidentals (never null)
 * - oct: a integer with the octave. If not present in the note, is set to 4
 *
 * @param {String} note - the note (pitch) to be parsed
 * @param {boolean} namePrefix - if name prefix is true, then a note name
 * (without octave) is extracted from the beggining of the string
 * @return an object with the note components
 */
function parse (note, namePrefix) {
  var m = (namePrefix ? NAME_PREFIX : NOTE).exec(note)
  if (!m) throw Error('Invalid note: ' + note)
  return { note: m[0], step: m[1].toUpperCase(),
    acc: m[2].replace(/x/g, '##'), oct: m[3] ? +m[3] : 4 }
}

module.exports = parse

},{}],32:[function(require,module,exports){

var step = require('./step')
var alteration = require('./alteration')

var SEMITONES = { C: 0, D: 2, E: 4, F: 5, G: 7, A: 9, B: 11 }

/**
 * Get the [pitch class](https://en.wikipedia.org/wiki/Pitch_class#Integer_notation)
 * of the note
 *
 * The pitch class is an integer value of the pitch where C=0, C#=1, D=2...B=11
 *
 * @example
 * pitchClass('C2') // => 0
 * pitchClass('C3') // => 0
 * pitchClass('C#') // => 1
 * pitchClass('Db') // => 1
 */
function pitchClass (note) {
  return SEMITONES[step(note)] + alteration(note)
}
module.exports = pitchClass

},{"./alteration":24,"./step":33}],33:[function(require,module,exports){

var parse = require('./parse')

/**
 * Get the step of a note (the letter in uppercase, ignoring the accidentals and octave)
 *
 * @param {String} note - the note to get the step of
 * @return {String} the step letter (__always in uppercase__)
 *
 * @example
 * step('C#4') // => 'C'
 * step('db7') // => 'D'
 */
function step (note) {
  return parse(note).step
}
module.exports = step

},{"./parse":31}],34:[function(require,module,exports){

/**
 * Transpose a note by an (diatonic) interval
 *
 * @see interval/transpose-diationic
 * @example
 * transpose('P5', 'D') // => 'A4'
 */
module.exports = require('../interval/transpose-interval')

},{"../interval/transpose-interval":21}],35:[function(require,module,exports){
var parse = require('../interval/parse')
var set = ['P1', 'm2', 'M2', 'm3', 'M3', 'P4', 'd5', 'P5', 'm6', 'M6', 'm7', 'M7']

/**
 * Returns a set of intervals that represents an harmonic chromatic scale
 *
 * The harmonic chromatic scale is the same whether rising or falling and
 * includes all the notes in the major, harmonic minor or melodic minor
 * scales plus flattened second and sharpened fourth degrees
 */
function chromaticIntervalSet (length) {
  if (length > set.length) set = upToOctave(set, length % 12)
  return set.slice(0, length)
}

module.exports = chromaticIntervalSet

function upToOctave (source, octave) {
  var interval, num
  var result = source.slice(0, 12)
  for (var oct = 1; oct <= octave; oct++) {
    num = oct * 8 - 1
    for (var i = 0; i < 12; i++) {
      interval = parse(source[i])
      result.push(interval.q + (interval.n + num))
    }
  }
  return result
}

},{"../interval/parse":16}],36:[function(require,module,exports){
var set = require('./set')

/**
 * Create a set generator from a hash map data and a name parser
 *
 * A set generator is a function that generates sets from strings. It uses
 * a parser to separate the tonic (if any) from the real name. Then look up
 * into the hash for a name and pass it to a set generator.
 *
 * If the name is not found in the hash data, it throws an exception
 *
 * @param {Hash} data - the data hash (dictionary)
 * @param {Function} parser - a function that parses the name and returns
 * an object with tonic (if not present) and the name properties
 *
 * For different parser implementations:
 * @see scale/parse
 * @see chord/parse
 *
 * @example
 * var scales = dictionary({'major': 2773})
 * scales('C major') // => ['C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'B4']
 */
function dictionary (data, parser) {
  parser = parser || parseName
  return function (name) {
    var parsed = parser(name)
    var setIdentifier = data[parsed.type]
    if (!setIdentifier) throw Error('Name not found: ' + parsed.type)
    return set(setIdentifier, parsed.tonic)
  }
}

module.exports = dictionary

var REGEX = /^([a-gA-G])?\s*(.*)$/
function parseName (name) {
  var m = REGEX.exec(name)
  return m ? { tonic: m[1], type: m[2] } : m
}

},{"./set":42}],37:[function(require,module,exports){
var isBinary = require('./is-binary-set')
var isIntervals = require('./is-interval-set')
var isNotes = require('./is-note-set')
var distance = require('../interval/distance-interval')
var chromatic = require('./chromatic-interval-set')

/**
 * Given a set identifier return the intervals
 *
 * @param {String|Decimal|Array} set - the set to get the intervals from
 * @return {Array} an array of intervals
 */
function intervalSet (set) {
  if (isBinary(set)) {
    return binaryIntervals(set.toString(2))
  }

  if (typeof (set) === 'string') set = set.split(' ')
  if (isIntervals(set)) {
    return set
  } else if (isNotes(set)) {
    var root = set[0]
    return set.map(function (note) {
      return distance(root, note)
    })
  }
}

module.exports = intervalSet

function binaryIntervals (binary) {
  var chroma = chromatic(binary.length)
  var result = []
  for (var i = 0, len = binary.length; i < len; i++) {
    if (binary[i] === '1') result.push(chroma[i])
  }
  return result
}

},{"../interval/distance-interval":9,"./chromatic-interval-set":35,"./is-binary-set":38,"./is-interval-set":39,"./is-note-set":40}],38:[function(require,module,exports){
'use strict'

var BINARY = /^1[01]*$/

/**
 * Determine if a given number is a valid binary set number
 *
 * A valid binary set is any binary number that starts with 1 (P1 interval)
 * The binary number can be expressed in decimal
 *
 * @param {String} number - the number to test
 * @return {boolean} true if its a valid scale binary number
 *
 * @example
 * isBinary('100') // => true
 * isBinarySet('010') // => false
 * isBinarySet(2773) // => true
 */
function isBinarySet (number) {
  return BINARY.test(number.toString(2))
}

module.exports = isBinarySet

},{}],39:[function(require,module,exports){
var isInterval = require('../interval/is-interval')

/**
 * Test is the given set is an interval set
 *
 * An interval set is an array where all items are inteval strings and
 * the first item is 'P1'
 *
 * @param {Object} set - the set to be tested
 * @return {Boolean} true if is an interval set
 *
 * @example
 * isIntervalSet(['P1']) // => true
 */
function isIntervalSet (set) {
  if (!Array.isArray(set)) return false
  if (set[0] !== 'P1') return false
  for (var i = 0, total = set.length; i < total; i++) {
    if (!isInterval(set[i])) return false
  }
  return true
}

module.exports = isIntervalSet

},{"../interval/is-interval":13}],40:[function(require,module,exports){
var isNote = require('../note/is-note')

/**
 * Test if the given set is a valid note set
 *
 * A valid note set is an array of note strings
 *
 * @param {Object} set - the set to be tested
 * @return {Boolean} true if is a note set
 */
function isNoteSet (set) {
  if (!Array.isArray(set)) return false
  for (var i = 0, total = set.length; i < total; i++) {
    if (!isNote(set[i])) return false
  }
  return true
}

module.exports = isNoteSet

},{"../note/is-note":27}],41:[function(require,module,exports){
var isNotes = require('./is-note-set')
var intervals = require('./interval-set')
var transpose = require('../note/transpose')

/**
 * Given a set and a note, return a set with the same intervals but starting from note
 *
 * @param {Array|String|Integer} set - the original set. Can be a notes or
 * intervals array, a binary string set or a decimal set
 */
function noteSet (set, root) {
  if (isNotes(set) && set[0] === root) return set
  return intervals(set).map(function (interval) {
    return transpose(interval, root)
  })
}

module.exports = noteSet

},{"../note/transpose":34,"./interval-set":37,"./is-note-set":40}],42:[function(require,module,exports){
var intervals = require('./interval-set')
var notes = require('./note-set')
/**
 * Create a set (either a group of intervals or notes depending if you provide
 * a tonic parameter or not)
 *
 * It uses `set/intervals` or `set/notes` depending
 * on the action. Is a convenience function when creating scales or chords
 *
 * @see scale/scale
 * @see chord/chord
 *
 * @param {String} note - the tonic note (can be null)
 * @param {String|Integer|Array} identifier - the set identifier
 * @return {Array} an array of notes or intervals
 */
function set (set, note) {
  if (!note || /^\s*$/.test(note)) {
    return intervals(set)
  } else {
    return notes(set, note)
  }
}

module.exports = set

},{"./interval-set":37,"./note-set":41}]},{},[1]);
